# Orchestrate Integrate - Layer 2 Configuration
# ==============================================
# This file is auto-copied to docs/orchestrate-integrate.config.yaml on first run.
# Customize the copy in docs/ folder for your project.
#
# Layer 2 includes ALL stages from:
# - Layer 0: Story preparation (create-story, validate)
# - Layer 1: Development & quality (develop, lint, typecheck, unit-test, code-review)
# - Layer 2 NEW: Git operations, PR automation, CI/CD monitoring, merge
#
# Execution Model: HYBRID
# - BMAD workflows: Spawned as separate agents (isolated context)
# - Bash commands: Direct execution (shared context)
# - Orchestration: Parent context (coordination)
#
# Prompt Variables (for spawn stages):
#   {story_id}      - The story identifier
#   {story_file}    - Path to story file
#   {errors}        - Error output from failed command (for fix stages)
#   {files_changed} - List of changed files
#   {pr_number}     - PR number (for pr-checks, pr-merge stages)
#   {pr_url}        - PR URL
#   {ci_logs}       - CI/CD failure logs (for pr-checks fixes)
#   {autonomy}      - Auto-injected autonomy instructions
#   {project_root}  - Absolute path to project root directory
#   {known_issues}  - Knowledge base lessons (auto-injected)

name: orchestrate-integrate
version: "1.0.0"
description: "Layer 2: Complete integration pipeline from story to merged PR"
layer: 2

# Autonomy instructions injected into all prompts
autonomy_instructions: |
  AUTONOMOUS MODE - NO QUESTIONS.
  Skip all menus, confirmations, and user prompts.
  Execute the task completely and output results only.
  Do not ask follow-up questions.

# Story file locations to check (in order)
story_locations:
  - "state/stories/${story_id}.md"
  - "docs/stories/${story_id}.md"
  - "docs/sprint-artifacts/${story_id}.md"

# PR Settings (Layer 2)
pr_settings:
  auto_merge: false                    # Set to true for automatic merge after checks pass
  merge_method: "squash"               # "squash", "merge", or "rebase"
  delete_branch_after_merge: true      # Delete feature branch after merge
  require_reviews: 0                   # Minimum human reviews required (0 = none)
  wait_for_checks: true                # Wait for CI/CD checks before merge

  # PR title and description templates
  title_template: "feat: {story_title}"
  description_template: |
    ## Story
    {story_id}: {story_title}

    ## Changes
    {changes_summary}

    ## Checklist
    - [x] Tests passing
    - [x] Lint passing
    - [x] Code reviewed by AI

    ü§ñ Auto-generated by orchestrate-integrate

# Git Settings (Layer 2)
git_settings:
  branch_prefix: "feat/"                # Branch naming prefix: "feat/", "feature/", "story/"
  base_branch: "main"                   # Target branch for PR: "main", "master", "develop"
  commit_message_template: |
    {commit_type}: {story_title}

    Story: {story_id}

    {changes_summary}

    Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>

# Knowledge Base Configuration
# Controls how lessons learned are captured and applied
knowledge_base:
  enabled: true                    # Enable/disable knowledge base system
  max_lessons_per_stage: null      # Max lessons to show per stage (null = all, 0 = all, number = limit)
  min_encounter_count: 1           # Minimum times a lesson must be seen to be included

  # Per-stage overrides (optional)
  stage_overrides:
    pr-checks:
      max_lessons: 15              # Show up to 15 lessons for PR/CI fixes
    # lint:
    #   max_lessons: 10
    # typecheck:
    #   max_lessons: 15

# Task Decomposition Configuration
# Controls task-by-task execution for large stories
task_decomposition:
  enabled: true                    # Enable/disable auto task decomposition
  threshold: 6                     # Decompose if >= N incomplete tasks (default: 6)

# ============================================
# STAGES: Layer 0 + Layer 1 + Layer 2
# ============================================

stages:
  # ============================================
  # LAYER 0: Story Preparation (Stages 1-2)
  # ============================================

  # Stage 1: Create story if file doesn't exist
  create-story:
    order: 1
    enabled: true
    execution: spawn
    type: bmad_workflow
    workflow: /bmad:bmm:workflows:create-story
    condition: story_file_not_exists
    timeout: 3600
    on_failure: abort
    description: "Create story file from epics if it doesn't exist (auto-detect if no story_id)"
    prompt: |
      /bmad:bmm:workflows:create-story
      {autonomy}

      {known_issues}

      Story ID (if provided): {story_id}

      If story_id is provided and not empty:
        - Create story file for this specific story
        - Find the epic it belongs to
        - Generate tasks and acceptance criteria

      If story_id is empty or not provided (auto-detect):
        - Read sprint-status.yaml or epic files
        - Find first story with status: "ready" or "in_progress"
        - If no ready stories, find first "not_started" epic
        - Create new story from that epic

      Output: story_id and story_file path

  # Stage 2: Validate story is ready for development
  validate:
    order: 2
    enabled: true
    execution: spawn
    type: bmad_workflow
    workflow: /bmad:bmm:workflows:implementation-readiness
    timeout: 3600
    on_failure: fix_and_retry
    retry:
      max: 2
      fix_prompt: "Fix the validation issues identified above"
    description: "Validate story has clear tasks and acceptance criteria"
    prompt: |
      /bmad:bmm:workflows:implementation-readiness
      {autonomy}

      {known_issues}

      Validate story is ready for development.
      Story file: {story_file}

      Check:
      - Clear acceptance criteria
      - Well-defined tasks
      - Dependencies documented

      Output: PASS or FAIL with details.

  # ============================================
  # LAYER 1: Development & Quality (Stages 3-7)
  # ============================================

  # Stage 3: Develop the story
  develop:
    order: 3
    enabled: true
    execution: spawn
    type: bmad_workflow
    workflow: /bmad:bmm:workflows:dev-story
    timeout: 21600
    on_failure: fix_and_retry
    retry:
      max: 3
      fix_prompt: "Continue development, addressing any issues"
    description: "Implement the story following tasks in story file"
    prompt: |
      /bmad:bmm:workflows:dev-story
      {autonomy}

      {known_issues}

      Implement the story following tasks in the story file.
      Story file: {story_file}
      Story ID: {story_id}

      Follow red-green-refactor cycle for each task.
      Output: List of files changed and implementation summary.

  # Stage 4: Run linting
  lint:
    order: 4
    enabled: true
    execution: spawn
    type: lint_check
    timeout: 3600
    on_failure: fix_and_retry
    retry:
      max: 3
    description: "Discover and run all project lint checks"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}

      You are a dev agent responsible for running ALL lint/format checks this project uses and fixing any issues.

      STEP 1: DISCOVER LINT TOOLS
      First, discover what lint/format tools this project uses by checking:

      1. Read package.json scripts section - look for:
         - "lint", "lint:fix", "eslint"
         - "format", "format:check", "prettier"
         - "check", "validate"
         - Any script containing "lint", "format", "check"

      2. Check for config files that indicate tools:
         - .eslintrc.* or eslint.config.* ‚Üí ESLint
         - .prettierrc.* or prettier.config.* ‚Üí Prettier
         - biome.json or biome.jsonc ‚Üí Biome
         - .stylelintrc.* ‚Üí Stylelint
         - .markdownlint.* ‚Üí Markdownlint

      3. Check package.json devDependencies for:
         - eslint, @eslint/* ‚Üí ESLint
         - prettier ‚Üí Prettier
         - @biomejs/biome ‚Üí Biome
         - stylelint ‚Üí Stylelint

      STEP 2: RUN ALL LINT CHECKS
      Run each discovered lint check command.

      STEP 3: FIX ALL ERRORS
      For each type of error found, fix them using appropriate methods.

      STEP 4: VERIFY ALL CHECKS PASS
      Re-run ALL discovered lint commands to ensure everything passes.

      Output:
      - List of lint tools discovered
      - Errors found and fixed
      - Final verification status

  # Stage 5: Run type checking
  typecheck:
    order: 5
    enabled: true
    execution: direct
    type: bash
    command: "npm run typecheck"
    timeout: 3600
    on_failure: fix_and_retry
    retry:
      max: 2
      fix_agent: /bmad:bmm:agents:dev
      fix_prompt: "Fix the TypeScript type errors shown above"
    description: "Check TypeScript types"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}

      You are a dev agent fixing TypeScript type errors. The typecheck command `npm run typecheck` failed.

      TYPE ERRORS:
      ```
      {errors}
      ```

      INSTRUCTIONS:
      1. Parse the error output to identify files and line numbers with type errors
      2. Read each file that has errors using the Read tool
      3. Understand the type mismatch and fix the type annotations or code logic
      4. Use the Edit tool to apply fixes
      5. After fixing, run `npm run typecheck` to verify all errors are resolved

      Common fixes:
      - Add missing type annotations
      - Fix incorrect types (string vs number, etc.)
      - Add null checks for potentially undefined values
      - Import missing type definitions

      Output: Summary of files fixed and changes made.

  # Stage 6: Run unit tests
  unit-test:
    order: 6
    enabled: true
    execution: direct
    type: bash
    command: "npm test"
    timeout: 3600
    on_failure: fix_and_retry
    retry:
      max: 3
      fix_agent: /bmad:bmm:agents:dev
      fix_prompt: "Fix the failing tests shown above"
    description: "Run all unit tests"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}

      You are a dev agent fixing failing unit tests. The test command `npm test` failed.

      TEST FAILURES:
      ```
      {errors}
      ```

      INSTRUCTIONS:
      1. Parse the error output to identify which tests failed and why
      2. Read the failing test file(s) using the Read tool
      3. Read the implementation file(s) being tested
      4. Determine if the bug is in the test or the implementation
      5. Use the Edit tool to apply fixes
      6. After fixing, run `npm test` to verify all tests pass

      Focus on fixing ONLY the failing tests. Do not add new tests or refactor passing code.

      Output: Summary of what was fixed and changes made.

  # Stage 7: Code review (non-blocking)
  code-review:
    order: 7
    enabled: true
    execution: spawn
    type: bmad_workflow
    workflow: /bmad:bmm:workflows:code-review
    timeout: 3600
    on_failure: continue
    blocking: false
    description: "Review code quality, security, and architecture"
    prompt: |
      /bmad:bmm:workflows:code-review
      {autonomy}

      {known_issues}

      Review the implemented code for story {story_id}.

      FILES CHANGED (max 20 files, max 100KB each):
      {files_changed}

      Review for:
      - Code quality
      - Security issues
      - Performance
      - Architecture compliance

      Output: Findings with severity levels.

  # ============================================
  # LAYER 2: Git & PR Automation (Stages 8-12)
  # ============================================

  # Stage 8: Create git commit
  git-commit:
    order: 8
    enabled: true
    execution: spawn
    type: git_operation
    timeout: 600
    on_failure: fix_and_retry
    retry:
      max: 2
    description: "Create git commit with AI-generated message"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}
      Story ID: {story_id}

      You are a git operations agent. Create a commit for the changes made.

      STEP 1: Check git status
      Run `git status` to see what files have changed.

      STEP 2: Stage changes
      Stage all relevant files using `git add <files>`.
      Do NOT stage:
      - .env files
      - credentials
      - node_modules
      - .DS_Store
      - temp files

      STEP 3: Generate commit message
      Create a conventional commit message following this template:

      {commit_type}: {story_title}

      Story: {story_id}

      Summary of changes (2-3 sentences)

      Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>

      Commit types: feat, fix, refactor, docs, test, chore

      STEP 4: Create commit
      Run `git commit -m "your message"` (use heredoc for multiline).

      STEP 5: Verify
      Run `git log -1` to verify commit was created.

      Output: Commit hash and message

  # Stage 9: Push to remote
  git-push:
    order: 9
    enabled: true
    execution: spawn
    type: git_operation
    timeout: 600
    on_failure: fix_and_retry
    retry:
      max: 2
    description: "Push changes to remote feature branch"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}
      Story ID: {story_id}
      Branch prefix: {branch_prefix}
      Base branch: {base_branch}

      You are a git operations agent. Push changes to remote.

      STEP 1: Check current branch
      Run `git branch --show-current` to see current branch name.

      STEP 2: Create feature branch if needed
      If current branch is {base_branch}:
        - Create feature branch: `git checkout -b {branch_prefix}{story_id}`
      Otherwise:
        - Use existing branch

      STEP 3: Ensure branch is tracking remote
      Run `git push -u origin <branch_name>` to push and set upstream.

      STEP 4: Verify
      Run `git status` to verify push was successful.

      Output: Branch name and remote URL

  # Stage 10: Create pull request
  pr-create:
    order: 10
    enabled: true
    execution: spawn
    type: pr_operation
    timeout: 600
    on_failure: fix_and_retry
    retry:
      max: 2
    description: "Create pull request with AI-generated description"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}
      Story ID: {story_id}
      Story file: {story_file}
      Base branch: {base_branch}

      You are a PR operations agent. Create a pull request using GitHub CLI.

      PREREQUISITES:
      Ensure `gh` CLI is installed and authenticated:
      - Run `gh auth status` to check authentication
      - If not authenticated, output error and abort

      STEP 1: Read story file
      Read {story_file} to get story title and description.

      STEP 2: Get changes summary
      Run `git diff {base_branch}...HEAD --stat` to get changes summary.

      STEP 3: Generate PR title and description
      Title: "feat: <story title>"
      Description:
        ## Story
        {story_id}: <story title>

        ## Changes
        <summary of what changed>

        ## Checklist
        - [x] Tests passing
        - [x] Lint passing
        - [x] Code reviewed by AI

        ü§ñ Auto-generated by orchestrate-integrate

      STEP 4: Create PR
      Run `gh pr create --title "..." --body "..." --base {base_branch}`.

      STEP 5: Get PR URL
      Parse output to extract PR number and URL.

      Output: PR number and URL

  # Stage 11: Monitor PR checks (with auto-fix loop)
  pr-checks:
    order: 11
    enabled: true
    execution: spawn
    type: pr_operation
    timeout: 1800                    # 30 minutes max
    on_failure: fix_and_retry
    retry:
      max: 5                         # Up to 5 fix attempts
    description: "Monitor CI/CD checks and auto-fix failures"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}
      PR number: {pr_number}
      PR URL: {pr_url}

      You are a PR operations agent. Monitor CI/CD checks and auto-fix any failures.

      MAIN LOOP (run until all checks pass or max time/retries):

      STEP 1: Check PR status
      Run `gh pr checks {pr_number}` to get current check status.

      STEP 2: Parse results
      Check if all checks are:
      - ‚úì PASS ‚Üí Exit successfully
      - ‚è≥ PENDING ‚Üí Wait 60 seconds, go to STEP 1
      - ‚úó FAIL ‚Üí Continue to STEP 3

      STEP 3: Get failure logs (if any checks failed)
      For each failed check:
      - Run `gh pr checks {pr_number} --watch` or `gh run view <run_id> --log`
      - Extract error messages and failure reasons

      STEP 4: Analyze failures
      Common CI/CD failures:
      - Lint errors ‚Üí Run lint fix agent
      - Test failures ‚Üí Run test fix agent
      - Build errors ‚Üí Run build fix agent
      - Dependency issues ‚Üí Update dependencies
      - Timeout errors ‚Üí Optimize tests

      STEP 5: Auto-fix
      Spawn appropriate fix agent with failure logs:
      - Read files mentioned in errors
      - Apply fixes using Edit tool
      - Commit and push fixes

      STEP 6: Wait for re-run
      After pushing fixes:
      - CI/CD will automatically re-run
      - Wait 60 seconds
      - Go to STEP 1

      MAX RETRIES: 5 fix attempts
      TIMEOUT: 30 minutes total

      If max retries or timeout reached:
      - Output: "CI/CD checks failed after max attempts"
      - Provide PR URL for manual intervention

      Output: Final check status (all passed or failed with details)

  # Stage 12: Merge pull request (configurable)
  pr-merge:
    order: 12
    enabled: true
    execution: spawn
    type: pr_operation
    condition: pr_checks_passed       # Only run if checks passed
    timeout: 300
    on_failure: fix_and_retry
    retry:
      max: 1
    description: "Merge PR (auto or prepare for manual)"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}
      PR number: {pr_number}
      PR URL: {pr_url}
      Auto-merge: {auto_merge}
      Merge method: {merge_method}

      You are a PR operations agent. Handle PR merge based on configuration.

      CONFIG CHECK:
      Auto-merge setting: {auto_merge}

      IF auto_merge = false:
        SKIP MERGE, PREPARE FOR MANUAL REVIEW:

        STEP 1: Verify PR is ready
        Run `gh pr checks {pr_number}` to confirm all checks passed.

        STEP 2: Output information for manual review
        Output:
        - ‚úì PR is ready for manual review
        - PR URL: {pr_url}
        - All CI/CD checks: PASSED
        - Please review and merge manually on GitHub

        EXIT with status: "ready_for_manual_merge"

      IF auto_merge = true:
        AUTO-MERGE PR:

        STEP 1: Verify merge requirements
        - All CI/CD checks passed
        - No merge conflicts
        - Branch is up to date with {base_branch}

        STEP 2: Check for conflicts
        Run `gh pr view {pr_number} --json mergeable` to check if mergeable.
        If conflicts exist:
          - Output error: "Merge conflicts detected, cannot auto-merge"
          - EXIT with failure

        STEP 3: Merge PR
        Run `gh pr merge {pr_number} --{merge_method} --auto`.

        Merge methods:
        - squash: Squash all commits into one
        - merge: Standard merge commit
        - rebase: Rebase and merge

        STEP 4: Delete branch (if configured)
        If delete_branch_after_merge = true:
          Run `gh pr close {pr_number}` (gh pr merge already deletes branch)

        STEP 5: Verify merge
        Run `gh pr view {pr_number} --json state,merged` to verify merged.

        Output: Merge status and final commit hash

# Output variables captured from execution
output:
  - story_id
  - story_file
  - files_changed
  - lint_result
  - typecheck_result
  - test_results
  - review_findings
  - commit_hash
  - branch_name
  - pr_number
  - pr_url
  - pr_status
  - merge_status
  - status
