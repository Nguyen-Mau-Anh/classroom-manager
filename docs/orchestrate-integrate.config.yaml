# Orchestrate Integrate - Layer 2 Configuration
# ==============================================
# This file is auto-copied to docs/orchestrate-integrate.config.yaml on first run.
# Customize the copy in docs/ folder for your project.
#
# Layer 2 includes ALL stages from:
# - Layer 0: Story preparation (create-story, validate)
# - Layer 1: Development & quality (develop, lint, typecheck, unit-test, code-review)
# - Layer 2 NEW: Git operations, PR automation, CI/CD monitoring, merge
#
# Execution Model: HYBRID
# - BMAD workflows: Spawned as separate agents (isolated context)
# - Bash commands: Direct execution (shared context)
# - Orchestration: Parent context (coordination)
#
# Prompt Variables (for spawn stages):
#   {story_id}      - The story identifier
#   {story_file}    - Path to story file
#   {errors}        - Error output from failed command (for fix stages)
#   {files_changed} - List of changed files
#   {pr_number}     - PR number (for pr-checks, pr-merge stages)
#   {pr_url}        - PR URL
#   {ci_logs}       - CI/CD failure logs (for pr-checks fixes)
#   {autonomy}      - Auto-injected autonomy instructions
#   {project_root}  - Absolute path to project root directory
#   {known_issues}  - Knowledge base lessons (auto-injected)

name: orchestrate-integrate
version: "1.0.0"
description: "Layer 2: Complete integration pipeline from story to merged PR"
layer: 2

# Autonomy instructions injected into all prompts
autonomy_instructions: |
  AUTONOMOUS MODE - NO QUESTIONS.
  Skip all menus, confirmations, and user prompts.
  Execute the task completely and output results only.
  Do not ask follow-up questions.

# Story file locations to check (in order)
story_locations:
  - "state/stories/${story_id}.md"
  - "docs/stories/${story_id}.md"
  - "docs/sprint-artifacts/${story_id}.md"

# PR Settings (Layer 2)
pr_settings:
  auto_merge: false                    # Set to true for automatic merge after checks pass
  merge_method: "squash"               # "squash", "merge", or "rebase"
  delete_branch_after_merge: true      # Delete feature branch after merge
  require_reviews: 0                   # Minimum human reviews required (0 = none)
  wait_for_checks: true                # Wait for CI/CD checks before merge

  # PR title and description templates
  title_template: "feat: {story_title}"
  description_template: |
    ## Story
    {story_id}: {story_title}

    ## Changes
    {changes_summary}

    ## Checklist
    - [x] Tests passing
    - [x] Lint passing
    - [x] Code reviewed by AI

    ü§ñ Auto-generated by orchestrate-integrate

# Git Settings (Layer 2)
git_settings:
  branch_prefix: "feat/"                # Branch naming prefix: "feat/", "feature/", "story/"
  base_branch: "main"                   # Target branch for PR: "main", "master", "develop"
  commit_message_template: |
    {commit_type}: {story_title}

    Story: {story_id}

    {changes_summary}

    Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>

# Knowledge Base Configuration
# Controls how lessons learned are captured and applied
knowledge_base:
  enabled: true                    # Enable/disable knowledge base system
  max_lessons_per_stage: null      # Max lessons to show per stage (null = all, 0 = all, number = limit)
  min_encounter_count: 1           # Minimum times a lesson must be seen to be included

  # Per-stage overrides (optional)
  stage_overrides:
    pr-checks:
      max_lessons: 15              # Show up to 15 lessons for PR/CI fixes
    # lint:
    #   max_lessons: 10
    # typecheck:
    #   max_lessons: 15

# ============================================
# STAGES: Layer 0 + Layer 1 + Layer 2
# ============================================

stages:
  # ============================================
  # LAYER 1: Delegate to orchestrate-dev
  # ============================================

  layer-1-execution:
    order: 1
    enabled: true
    execution: delegate
    type: layer_call
    delegate_to: "/orchestrate-dev"
    timeout: 28800  # 8 hours for full Layer 1 execution (prepare + dev + quality)
    on_failure: abort
    description: "Execute Layer 1: Story preparation + development + quality checks"
    # This delegates to /orchestrate-dev which will:
    # - Layer 0 (via delegation): create-story, validate
    # - Layer 1: develop, lint, typecheck, unit-test, code-review

  # ============================================
  # LAYER 2: Git & PR Automation (Stages 8-12)
  # ============================================

  # Stage 8: Create git commit
  git-commit:
    order: 8
    enabled: true
    execution: spawn
    type: git_operation
    timeout: 600
    on_failure: fix_and_retry
    retry:
      max: 2
    description: "Create git commit with AI-generated message"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}
      Story ID: {story_id}

      You are a git operations agent. Create a commit for the changes made.

      STEP 1: Check git status
      Run `git status` to see what files have changed.

      STEP 2: Stage changes
      Stage all relevant files using `git add <files>`.
      Do NOT stage:
      - .env files
      - credentials
      - node_modules
      - .DS_Store
      - temp files

      STEP 3: Generate commit message
      Create a conventional commit message following this template:

      {commit_type}: {story_title}

      Story: {story_id}

      Summary of changes (2-3 sentences)

      Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>

      Commit types: feat, fix, refactor, docs, test, chore

      STEP 4: Create commit
      Run `git commit -m "your message"` (use heredoc for multiline).

      STEP 5: Verify
      Run `git log -1` to verify commit was created.

      Output: Commit hash and message

  # Stage 9: Push to remote
  git-push:
    order: 9
    enabled: true
    execution: spawn
    type: git_operation
    timeout: 600
    on_failure: fix_and_retry
    retry:
      max: 2
    description: "Push changes to remote feature branch"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}
      Story ID: {story_id}
      Branch prefix: {branch_prefix}
      Base branch: {base_branch}

      You are a git operations agent. Push changes to remote.

      STEP 1: Check current branch
      Run `git branch --show-current` to see current branch name.

      STEP 2: Create feature branch if needed
      If current branch is {base_branch}:
        - Create feature branch: `git checkout -b {branch_prefix}{story_id}`
      Otherwise:
        - Use existing branch

      STEP 3: Ensure branch is tracking remote
      Run `git push -u origin <branch_name>` to push and set upstream.

      STEP 4: Verify
      Run `git status` to verify push was successful.

      Output: Branch name and remote URL

  # Stage 10: Create pull request
  pr-create:
    order: 10
    enabled: true
    execution: spawn
    type: pr_operation
    timeout: 600
    on_failure: fix_and_retry
    retry:
      max: 2
    description: "Create pull request with AI-generated description"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}
      Story ID: {story_id}
      Story file: {story_file}
      Base branch: {base_branch}

      You are a PR operations agent. Create a pull request using GitHub CLI.

      PREREQUISITES:
      Ensure `gh` CLI is installed and authenticated:
      - Run `gh auth status` to check authentication
      - If not authenticated, output error and abort

      STEP 1: Read story file
      Read {story_file} to get story title and description.

      STEP 2: Get changes summary
      Run `git diff {base_branch}...HEAD --stat` to get changes summary.

      STEP 3: Generate PR title and description
      Title: "feat: <story title>"
      Description:
        ## Story
        {story_id}: <story title>

        ## Changes
        <summary of what changed>

        ## Checklist
        - [x] Tests passing
        - [x] Lint passing
        - [x] Code reviewed by AI

        ü§ñ Auto-generated by orchestrate-integrate

      STEP 4: Create PR
      Run `gh pr create --title "..." --body "..." --base {base_branch}`.

      STEP 5: Get PR URL
      Parse output to extract PR number and URL.

      Output: PR number and URL

  # Stage 11: Monitor PR checks (with auto-fix loop)
  pr-checks:
    order: 11
    enabled: true
    execution: spawn
    type: pr_operation
    timeout: 1800                    # 30 minutes max
    on_failure: fix_and_retry
    retry:
      max: 5                         # Up to 5 fix attempts
    description: "Monitor CI/CD checks and auto-fix failures"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}
      PR number: {pr_number}
      PR URL: {pr_url}

      You are a PR operations agent. Monitor CI/CD checks and auto-fix any failures.

      MAIN LOOP (run until all checks pass or max time/retries):

      STEP 1: Check PR status
      Run `gh pr checks {pr_number}` to get current check status.

      STEP 2: Parse results
      Check if all checks are:
      - ‚úì PASS ‚Üí Exit successfully
      - ‚è≥ PENDING ‚Üí Wait 60 seconds, go to STEP 1
      - ‚úó FAIL ‚Üí Continue to STEP 3

      STEP 3: Get failure logs (if any checks failed)
      For each failed check:
      - Run `gh pr checks {pr_number} --watch` or `gh run view <run_id> --log`
      - Extract error messages and failure reasons

      STEP 4: Analyze failures
      Common CI/CD failures:
      - Lint errors ‚Üí Run lint fix agent
      - Test failures ‚Üí Run test fix agent
      - Build errors ‚Üí Run build fix agent
      - Dependency issues ‚Üí Update dependencies
      - Timeout errors ‚Üí Optimize tests

      STEP 5: Auto-fix
      Spawn appropriate fix agent with failure logs:
      - Read files mentioned in errors
      - Apply fixes using Edit tool
      - Commit and push fixes

      STEP 6: Wait for re-run
      After pushing fixes:
      - CI/CD will automatically re-run
      - Wait 60 seconds
      - Go to STEP 1

      MAX RETRIES: 5 fix attempts
      TIMEOUT: 30 minutes total

      If max retries or timeout reached:
      - Output: "CI/CD checks failed after max attempts"
      - Provide PR URL for manual intervention

      Output: Final check status (all passed or failed with details)

  # Stage 12: Merge pull request (configurable)
  pr-merge:
    order: 12
    enabled: true
    execution: spawn
    type: pr_operation
    condition: pr_checks_passed       # Only run if checks passed
    timeout: 300
    on_failure: fix_and_retry
    retry:
      max: 1
    description: "Merge PR (auto or prepare for manual)"
    prompt: |
      {autonomy}

      {known_issues}

      PROJECT ROOT: {project_root}
      PR number: {pr_number}
      PR URL: {pr_url}
      Auto-merge: {auto_merge}
      Merge method: {merge_method}

      You are a PR operations agent. Handle PR merge based on configuration.

      CONFIG CHECK:
      Auto-merge setting: {auto_merge}

      IF auto_merge = false:
        SKIP MERGE, PREPARE FOR MANUAL REVIEW:

        STEP 1: Verify PR is ready
        Run `gh pr checks {pr_number}` to confirm all checks passed.

        STEP 2: Output information for manual review
        Output:
        - ‚úì PR is ready for manual review
        - PR URL: {pr_url}
        - All CI/CD checks: PASSED
        - Please review and merge manually on GitHub

        EXIT with status: "ready_for_manual_merge"

      IF auto_merge = true:
        AUTO-MERGE PR:

        STEP 1: Verify merge requirements
        - All CI/CD checks passed
        - No merge conflicts
        - Branch is up to date with {base_branch}

        STEP 2: Check for conflicts
        Run `gh pr view {pr_number} --json mergeable` to check if mergeable.
        If conflicts exist:
          - Output error: "Merge conflicts detected, cannot auto-merge"
          - EXIT with failure

        STEP 3: Merge PR
        Run `gh pr merge {pr_number} --{merge_method} --auto`.

        Merge methods:
        - squash: Squash all commits into one
        - merge: Standard merge commit
        - rebase: Rebase and merge

        STEP 4: Delete branch (if configured)
        If delete_branch_after_merge = true:
          Run `gh pr close {pr_number}` (gh pr merge already deletes branch)

        STEP 5: Verify merge
        Run `gh pr view {pr_number} --json state,merged` to verify merged.

        Output: Merge status and final commit hash

# Output variables captured from execution
output:
  - story_id
  - story_file
  - files_changed
  - lint_result
  - typecheck_result
  - test_results
  - review_findings
  - commit_hash
  - branch_name
  - pr_number
  - pr_url
  - pr_status
  - merge_status
  - status
